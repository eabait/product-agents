import { createOpenRouter } from '@openrouter/ai-sdk-provider'
import { generateObject, generateText, streamText, streamObject } from 'ai'
import { z } from 'zod'
import { GenerationUsage } from '@product-agents/agent-core'

// ---- Pricing & helpers ----
type ModelPrice = { inputPerMTok: number; outputPerMTok: number }
const MILLION = 1_000_000

// Key by the *served* model string from the header, e.g. "anthropic/claude-3-5-sonnet"
const PRICING: Record<string, ModelPrice> = {
  'anthropic/claude-3-5-sonnet': { inputPerMTok: 3.0, outputPerMTok: 15.0 },
  'anthropic/claude-3-7-sonnet': { inputPerMTok: 3.0, outputPerMTok: 15.0 },
  'anthropic/claude-3-haiku': { inputPerMTok: 0.25, outputPerMTok: 1.25 },
  'anthropic/claude-3-opus': { inputPerMTok: 15.0, outputPerMTok: 75.0 },
  'mistralai/mistral-large': { inputPerMTok: 2.0, outputPerMTok: 6.0 },
  'mistralai/mistral-large-2407': { inputPerMTok: 2.0, outputPerMTok: 6.0 },
  'mistralai/mistral-large-2411': { inputPerMTok: 2.0, outputPerMTok: 6.0 },
  'openai/gpt-3.5-turbo': { inputPerMTok: 0.5, outputPerMTok: 1.5 },
  'openai/gpt-3.5-turbo-0613': { inputPerMTok: 1.0, outputPerMTok: 2.0 },
  'openai/gpt-3.5-turbo-16k': { inputPerMTok: 3.0, outputPerMTok: 4.0 },
  'openai/gpt-4': { inputPerMTok: 30.0, outputPerMTok: 60.0 },
  'openai/gpt-4-0314': { inputPerMTok: 30.0, outputPerMTok: 60.0 },
  'openai/gpt-4-turbo': { inputPerMTok: 10.0, outputPerMTok: 30.0 },
  'openai/gpt-4-turbo-preview': { inputPerMTok: 10.0, outputPerMTok: 30.0 },
  'openai/gpt-4-1106-preview': { inputPerMTok: 10.0, outputPerMTok: 30.0 },
  'openai/gpt-4o': { inputPerMTok: 2.5, outputPerMTok: 10.0 },
  'openai/gpt-4o-2024-05-13': { inputPerMTok: 5.0, outputPerMTok: 15.0 },
  'openai/gpt-4o-2024-08-06': { inputPerMTok: 2.5, outputPerMTok: 10.0 },
  'openai/gpt-4o-2024-11-20': { inputPerMTok: 2.5, outputPerMTok: 10.0 },
  'openai/gpt-4o-mini': { inputPerMTok: 0.15, outputPerMTok: 0.6 },
  'openai/gpt-4o-mini-2024-07-18': { inputPerMTok: 0.15, outputPerMTok: 0.6 },
  'openai/gpt-4o-audio-preview': { inputPerMTok: 2.5, outputPerMTok: 10.0 },
  'openai/gpt-4o:extended': { inputPerMTok: 6.0, outputPerMTok: 18.0 },
  'openai/gpt-4.1': { inputPerMTok: 2.0, outputPerMTok: 8.0 },
  'openai/gpt-4.1-mini': { inputPerMTok: 0.4, outputPerMTok: 1.6 },
  'openai/gpt-4.1-nano': { inputPerMTok: 0.1, outputPerMTok: 0.4 }
}

function computeCost(promptTokens: number | undefined, completionTokens: number | undefined, p: ModelPrice) {
  const promptCost = promptTokens !== undefined ? (promptTokens / MILLION) * p.inputPerMTok : undefined
  const completionCost = completionTokens !== undefined ? (completionTokens / MILLION) * p.outputPerMTok : undefined
  const totalCost =
    promptCost !== undefined || completionCost !== undefined
      ? (promptCost ?? 0) + (completionCost ?? 0)
      : undefined
  return { promptCost, completionCost, totalCost, currency: 'USD' as const }
}

function extractOpenRouterIdentity(resp?: Response) {
  if (!resp) return { model: undefined as string | undefined, provider: undefined as string | undefined }

  const getHeader = (headerName: string): string | undefined => {
    const headers: any = (resp as any).headers
    if (!headers) return undefined
    if (typeof headers.get === 'function') {
      const value = headers.get(headerName)
      return value ?? headers.get(headerName.toLowerCase()) ?? undefined
    }
    if (headers instanceof Map) {
      const value = headers.get(headerName) ?? headers.get(headerName.toLowerCase())
      return typeof value === 'string' ? value : undefined
    }
    if (Array.isArray(headers)) {
      const item = headers.find(
        (entry: any) => Array.isArray(entry) && typeof entry[0] === 'string' && entry[0].toLowerCase() === headerName.toLowerCase()
      )
      return item && typeof item[1] === 'string' ? item[1] : undefined
    }
    if (typeof headers === 'object') {
      const key = Object.keys(headers).find((k) => k.toLowerCase() === headerName.toLowerCase())
      const value = key ? headers[key] : undefined
      return typeof value === 'string' ? value : undefined
    }
    return undefined
  }

  const model = getHeader('x-openrouter-model') || undefined        // e.g. "anthropic/claude-3-5-sonnet"
  const provider = getHeader('x-openrouter-provider') || (model ? model.split('/')[0] : undefined)
  return { model, provider }
}

async function resolveMaybePromise<T>(value: T | Promise<T> | undefined): Promise<T | undefined> {
  if (value && typeof (value as any).then === 'function') {
    try {
      return await value
    } catch {
      return undefined
    }
  }
  return value
}

/**
 * OpenRouter client for AI model interactions with streaming support
 * Provides structured generation, text generation, and streaming capabilities
 */
export class OpenRouterClient {
  private provider: any
  private lastUsage?: GenerationUsage
  
  /**
   * Initialize OpenRouter client
   * @param apiKey - Optional API key, defaults to environment variable
   */
  constructor(apiKey?: string) {
    this.provider = createOpenRouter({
      apiKey: apiKey || process.env.OPENROUTER_API_KEY || '',
      baseURL: 'https://openrouter.ai/api/v1',
      compatibility: 'strict',
      extraBody: {
        usage: {
          include: true
        }
      }
    })
  }
  
  getModel(modelName: string = 'anthropic/claude-3-5-sonnet') {
    return this.provider(modelName)
  }

  getLastUsage(): GenerationUsage | undefined {
    if (!this.lastUsage) {
      return undefined
    }
    return { ...this.lastUsage }
  }

  private resetUsage(): void {
    this.lastUsage = undefined
  }

  private captureUsage(requestedModel: string, usage: any, resp?: Response, providerMetadata?: any): void {
    if (!usage) { this.lastUsage = undefined; return }

    const promptTokens = this.coerceNumber(
      usage.promptTokens ?? usage.prompt_tokens ?? usage.inputTokens ?? usage.input_tokens ?? usage.inputTextTokens ?? usage.input_text_tokens
    )

    const completionTokens = this.coerceNumber(
      usage.completionTokens ?? usage.completion_tokens ?? usage.outputTokens ?? usage.output_tokens ?? usage.outputTextTokens ?? usage.output_text_tokens
    )

    let totalTokens = this.coerceNumber(
      usage.totalTokens ?? usage.total_tokens ?? usage.tokens ?? usage.token_count
    )
    if (totalTokens === undefined) {
      if (promptTokens !== undefined || completionTokens !== undefined) {
        totalTokens = (promptTokens ?? 0) + (completionTokens ?? 0)
      }
    }

    // Identify the actual served model/provider from OpenRouter headers; fall back to usage.model/requestedModel
    const { model: servedModelHdr, provider: servedProviderHdr } = extractOpenRouterIdentity(resp)
    const servedModel = servedModelHdr ?? (typeof usage.model === 'string' ? usage.model : requestedModel)
    const servedProvider = servedProviderHdr ?? (servedModel ? servedModel.split('/')[0] : undefined)

    // Compute cost from our pricing table (OpenRouter does not return prices in usage)
    const price = servedModel ? PRICING[servedModel] : undefined
    const cost = price ? computeCost(promptTokens, completionTokens, price) : undefined

    // Keep your providerMetadata fallback (optional)
    const providerFromMetadata = this.extractProvider(providerMetadata)
    const currencyFromMeta =
      this.normalizeCurrency(usage.currency) ??
      this.normalizeCurrency(usage.cost?.currency) ??
      this.normalizeCurrency(providerMetadata?.currency) ??
      this.normalizeCurrency(providerMetadata?.usage?.currency) ??
      this.normalizeCurrency(providerMetadata?.openrouter?.usage?.currency)

    this.lastUsage = {
      model: servedModel,
      provider: servedProvider ?? providerFromMetadata,
      promptTokens,
      completionTokens,
      totalTokens,
      promptCost: cost?.promptCost,
      completionCost: cost?.completionCost,
      totalCost: cost?.totalCost,
      currency: cost?.currency ?? currencyFromMeta ?? 'USD',
      rawUsage: usage
    }

    this.logUsage(servedModel, this.lastUsage)
  }

  private coerceNumber(value: unknown): number | undefined {
    if (typeof value === 'number') {
      return Number.isFinite(value) ? value : undefined
    }
    if (typeof value === 'string') {
      const parsed = parseFloat(value)
      return Number.isFinite(parsed) ? parsed : undefined
    }
    return undefined
  }

  private normalizeCurrency(value: unknown): string | undefined {
    if (typeof value === 'string' && value.trim().length > 0) {
      return value.trim().toUpperCase()
    }
    return undefined
  }

  private extractProvider(metadata: any): string | undefined {
    if (!metadata) return undefined
    const provider =
      metadata.provider ||
      metadata.id ||
      metadata.name ||
      metadata?.openrouter?.provider ||
      metadata?.openrouter?.id

    return typeof provider === 'string' ? provider : undefined
  }

  private logUsage(model: string | undefined, usage: GenerationUsage | undefined): void {
    if (!usage) return

    const promptCost = usage.promptCost
    const completionCost = usage.completionCost
    const totalCost =
      usage.totalCost ??
      (promptCost !== undefined || completionCost !== undefined
        ? (promptCost ?? 0) + (completionCost ?? 0)
        : undefined)

    console.log('[OpenRouterUsage]', {
      model,
      provider: usage.provider,
      promptTokens: usage.promptTokens ?? null,
      completionTokens: usage.completionTokens ?? null,
      totalTokens: usage.totalTokens ?? null,
      promptCost: promptCost ?? null,
      completionCost: completionCost ?? null,
      totalCost: totalCost ?? null,
      currency: usage.currency ?? 'USD'
    })
  }
  
  async generateStructured<T>(params: {
    model: string
    schema: z.ZodSchema<T>
    prompt: string
    temperature?: number
    maxTokens?: number
    arrayFields?: string[] // Optional array fields for post-processing fallback
  }): Promise<T> {
    this.resetUsage()
    try {
      const response = await generateObject({
        model: this.getModel(params.model),
        schema: params.schema,
        prompt: params.prompt,
        temperature: params.temperature || 0.3,
        maxTokens: params.maxTokens || 8000
      })
      const resp = await resolveMaybePromise<Response>((response as any)?.response)
      const providerMetadata = await resolveMaybePromise<any>((response as any)?.providerMetadata)
      this.captureUsage(params.model, response.usage, resp, providerMetadata)
      return response.object
    } catch (error: any) {
      // Enhanced fallback handling for various response malformation issues
      const shouldAttemptFallback = error.message?.includes('validation') || 
                                   error.message?.includes('Expected array') ||
                                   error.message?.includes('Required') ||
                                   error.message?.includes('Invalid') ||
                                   error.message?.includes('parse')
      
      if (shouldAttemptFallback) {
        console.warn('Schema validation failed, attempting enhanced fallback...', error.message)
        
        try {
          // Generate without schema validation to get raw response
          const text = await this.generateText({
            model: params.model,
            prompt: params.prompt + '\n\nCRITICAL: Return ONLY valid JSON. No XML tags, parameter names, or additional text.',
            temperature: params.temperature || 0.3,
            maxTokens: params.maxTokens || 8000
          })
          
          // Apply comprehensive response preprocessing
          const sanitizedJson = this.sanitizeResponse(text)
          const rawObject = JSON.parse(sanitizedJson)
          
          // Apply post-processing for array fields if specified
          const processedObject = params.arrayFields && params.arrayFields.length > 0 
            ? this.ensureArrayFields(rawObject, params.arrayFields)
            : rawObject
          
          // Validate the processed object
          const validatedObject = params.schema.parse(processedObject)
          
          console.log('Enhanced fallback preprocessing succeeded')
          return validatedObject
        } catch (fallbackError) {
          console.error('Enhanced fallback failed:', fallbackError)
          console.error('Original error:', error)
          throw error // Re-throw original error if fallback fails
        }
      }
      
      throw error
    }
  }

  /**
   * Sanitizes malformed AI responses that contain XML-like parameter tags mixed with JSON
   * Handles patterns like: {"field": "value", <parameter name="field2">value2</parameter>}
   */
  private sanitizeResponse(responseText: string): string {
    try {
      // First, try to parse as-is (fast path for well-formed JSON)
      JSON.parse(responseText.trim())
      return responseText.trim()
    } catch {
      // Response needs sanitization
    }

    let sanitized = responseText.trim()
    
    // Remove backticks and markdown code block markers
    sanitized = sanitized.replace(/^```json\s*/g, '').replace(/```\s*$/g, '')
    sanitized = sanitized.replace(/^```\s*/g, '').replace(/```\s*$/g, '')
    
    // Remove any text before the first { or [
    const jsonStart = sanitized.search(/^[\s]*[{[]/)
    if (jsonStart > 0) {
      sanitized = sanitized.substring(jsonStart)
    }
    
    // Remove any text after the last } or ]
    const jsonEnd = sanitized.lastIndexOf(sanitized.startsWith('[') ? ']' : '}')
    if (jsonEnd !== -1 && jsonEnd < sanitized.length - 1) {
      sanitized = sanitized.substring(0, jsonEnd + 1)
    }

    // Enhanced XML parameter extraction - handle multiple patterns
    if (process.env.NODE_ENV === 'development') {
      console.log('Raw response before XML parameter extraction:', sanitized.substring(0, 200));
    }

    // Pattern 1: Handle XML-like parameter tags with proper closing: <parameter name="fieldName">value</parameter>
    sanitized = sanitized.replace(
      /<parameter\s+name="([^"]+)"[^>]*>(.*?)<\/parameter>/gs,
      (match, fieldName, value) => {
        if (process.env.NODE_ENV === 'development') {
          console.log(`Found closed XML parameter: ${fieldName}, value length: ${value.length}`);
        }
        try {
          // Test if value is valid JSON
          JSON.parse(value.trim())
          return `"${fieldName}": ${value.trim()}`
        } catch {
          return `"${fieldName}": "${value.replace(/"/g, '\\"').trim()}"`
        }
      }
    )

    // Pattern 2: Handle unclosed XML parameter tags that extend to end of object/array or next field
    // This is the key pattern for our issue: <parameter name="fieldName">[JSON content]
    sanitized = sanitized.replace(
      /,\s*<parameter\s+name="([^"]+)"[^>]*>(\[[\s\S]*?\])/g,
      (match, fieldName, value) => {
        if (process.env.NODE_ENV === 'development') {
          console.log(`Found unclosed XML parameter with array: ${fieldName}, value length: ${value.length}`);
        }
        try {
          // Validate that it's a proper JSON array
          JSON.parse(value.trim())
          return `, "${fieldName}": ${value.trim()}`
        } catch (e) {
          if (process.env.NODE_ENV === 'development') {
            console.warn(`Failed to parse array value for ${fieldName}:`, e);
          }
          return `, "${fieldName}": []`
        }
      }
    )

    // Pattern 3: Handle unclosed XML parameter tags that extend to end of object/array or next field
    // Alternative pattern: <parameter name="fieldName">JSON_OBJECT
    sanitized = sanitized.replace(
      /,\s*<parameter\s+name="([^"]+)"[^>]*>(\{[\s\S]*?\})/g,
      (match, fieldName, value) => {
        console.log(`Found unclosed XML parameter with object: ${fieldName}, value length: ${value.length}`);
        try {
          // Validate that it's a proper JSON object
          JSON.parse(value.trim())
          return `, "${fieldName}": ${value.trim()}`
        } catch (e) {
          console.warn(`Failed to parse object value for ${fieldName}:`, e);
          return `, "${fieldName}": {}`
        }
      }
    )

    // Pattern 4: Handle unclosed XML parameter at start of response
    sanitized = sanitized.replace(
      /^(\s*\{[^}]*),?\s*<parameter\s+name="([^"]+)"[^>]*>(\[[\s\S]*?\])/,
      (match, prefix, fieldName, value) => {
        console.log(`Found leading XML parameter with array: ${fieldName}, value length: ${value.length}`);
        try {
          JSON.parse(value.trim())
          return `${prefix}, "${fieldName}": ${value.trim()}`
        } catch (e) {
          console.warn(`Failed to parse leading array value for ${fieldName}:`, e);
          return `${prefix}, "${fieldName}": []`
        }
      }
    )

    // Pattern 5: Handle simple unclosed parameter tags: <parameter name="fieldName">simple_value
    sanitized = sanitized.replace(
      /<parameter\s+name="([^"]+)"[^>]*>([^<]*?)(?=\s*[,}\]\s]|$)/g,
      (match, fieldName, value) => {
        console.log(`Found simple XML parameter: ${fieldName}, value: ${value.trim()}`);
        try {
          JSON.parse(value.trim())
          return `"${fieldName}": ${value.trim()}`
        } catch {
          return `"${fieldName}": "${value.replace(/"/g, '\\"').trim()}"`
        }
      }
    )

    // Pattern 6: Handle standalone parameter tags: <parameter name="fieldName"/>
    sanitized = sanitized.replace(
      /<parameter\s+name="([^"]+)"\s*\/>/g,
      (match, fieldName) => {
        console.log(`Found standalone XML parameter: ${fieldName}`);
        return `"${fieldName}": null`
      }
    )

    if (process.env.NODE_ENV === 'development') {
      console.log('After XML parameter extraction:', sanitized.substring(0, 200));
    }

    // Clean up any remaining XML artifacts before fixing commas
    sanitized = sanitized.replace(/<[^>]+>/g, '')

    // Fix missing commas between JSON fields - be more careful about this
    // Only add commas if there isn't already one
    sanitized = sanitized.replace(/([}\]])(\s*)("([^"]+)":)/g, (match, closer, whitespace, fieldPart, fieldName) => {
      return `${closer},${whitespace}${fieldPart}`
    })
    
    // Fix cases where we have a value followed by a field without comma
    sanitized = sanitized.replace(/(:\s*"[^"]*")(\s*)("([^"]+)":)/g, '$1,$2$3')
    sanitized = sanitized.replace(/(:\s*\[[^\]]*\])(\s*)("([^"]+)":)/g, '$1,$2$3')
    sanitized = sanitized.replace(/(:\s*\{[^}]*\})(\s*)("([^"]+)":)/g, '$1,$2$3')

    if (process.env.NODE_ENV === 'development') {
      console.log('After comma fixes:', sanitized.substring(0, 200));
    }
    
    // Fix trailing commas
    sanitized = sanitized.replace(/,(\s*[}\]])/g, '$1')
    
    // Validate the sanitized JSON
    try {
      JSON.parse(sanitized)
      if (process.env.NODE_ENV === 'development') {
        console.log('Response sanitization successful')
      }
      return sanitized
    } catch (parseError) {
      console.error('Failed to sanitize malformed response:', parseError)
      if (process.env.NODE_ENV === 'development') {
        console.error('Original response:', responseText)
        console.error('Sanitized attempt:', sanitized)
      }
      throw new Error(`Unable to sanitize malformed AI response: ${parseError}`)
    }
  }

  private ensureArrayFields(obj: any, arrayFields: string[]): any {
    if (!obj || typeof obj !== 'object') return obj
    
    const processedObj = { ...obj }
    
    function processObject(target: any, path: string = ''): any {
      if (!target || typeof target !== 'object' || Array.isArray(target)) {
        return target
      }
      
      const result: any = {}
      
      for (const [key, value] of Object.entries(target)) {
        const currentPath = path ? `${path}.${key}` : key
        
        if (arrayFields.includes(currentPath)) {
          if (typeof value === 'string') {
            try {
              result[key] = JSON.parse(value)
            } catch {
              console.warn(`Failed to parse JSON string for field ${currentPath}, using empty array`)
              result[key] = []
            }
          } else if (!Array.isArray(value)) {
            result[key] = []
          } else {
            result[key] = value
          }
        } else if (typeof value === 'object' && !Array.isArray(value)) {
          result[key] = processObject(value, currentPath)
        } else {
          result[key] = value
        }
      }
      
      return result
    }
    
    return processObject(processedObj)
  }
  
  async generateText(params: {
    model: string
    prompt: string
    temperature?: number
    maxTokens?: number
  }): Promise<string> {
    this.resetUsage()
    const response = await generateText({
      model: this.getModel(params.model),
      prompt: params.prompt,
      temperature: params.temperature || 0.7,
      maxTokens: params.maxTokens || 2000
    })

    const resp = await resolveMaybePromise<Response>((response as any)?.response)
    const providerMetadata = await resolveMaybePromise<any>((response as any)?.providerMetadata)
    this.captureUsage(params.model, response.usage, resp, providerMetadata)
    
    return response.text
  }
  
  async *streamText(params: {
    model: string
    prompt: string
    temperature?: number
  }) {
    this.resetUsage()
    const stream = await streamText({
      model: this.getModel(params.model),
      prompt: params.prompt,
      temperature: params.temperature || 0.7
    })

    const respPromise = resolveMaybePromise<Response>((stream as any)?.response)
    const usagePromise = resolveMaybePromise<any>((stream as any)?.usage)
    const providerMetadataPromise = resolveMaybePromise<any>((stream as any)?.providerMetadata)
    
    for await (const chunk of stream.textStream) {
      yield chunk
    }

    const [usage, providerMetadata, resp] = await Promise.all([usagePromise, providerMetadataPromise, respPromise])
    this.captureUsage(params.model, usage, resp, providerMetadata)
  }

  /**
   * Stream structured data generation with progress callbacks
   * Emits partial objects as they're being constructed by the AI
   * @param params - Configuration for streaming structured generation
   * @param params.model - Model identifier to use
   * @param params.schema - Zod schema for output validation
   * @param params.prompt - Input prompt for generation
   * @param params.temperature - Optional temperature setting (0-2)
   * @param params.maxTokens - Optional maximum tokens to generate
   * @param params.onProgress - Optional callback for progress updates
   * @returns AsyncIterableIterator yielding partial and complete objects
   */
  async *streamStructured<T>(params: {
    model: string
    schema: z.ZodSchema<T>
    prompt: string
    temperature?: number
    maxTokens?: number
    onProgress?: (partialObject: Partial<T> | T, type: 'partial' | 'complete') => void
  }): AsyncIterableIterator<{
    type: 'partial' | 'complete'
    object: Partial<T> | T
  }> {
    try {
      this.resetUsage()
      const stream = await streamObject({
        model: this.getModel(params.model),
        schema: params.schema,
        prompt: params.prompt,
        temperature: params.temperature || 0.3,
        maxTokens: params.maxTokens || 8000
      })
      const respPromise = resolveMaybePromise<Response>((stream as any)?.response)
      const usagePromise = resolveMaybePromise<any>((stream as any)?.usage)
      const providerMetadataPromise = resolveMaybePromise<any>((stream as any)?.providerMetadata)

      // Stream partial objects as they arrive
      for await (const partialObject of stream.partialObjectStream) {
        const streamItem = {
          type: 'partial' as const,
          object: partialObject as Partial<T>
        }
        
        // Call progress callback if provided
        if (params.onProgress) {
          params.onProgress(partialObject as Partial<T>, 'partial')
        }
        
        yield streamItem
      }

      // Yield the final complete object
      const finalResult = await stream.object
      const [usage, providerMetadata, resp] = await Promise.all([usagePromise, providerMetadataPromise, respPromise])
      this.captureUsage(params.model, usage, resp, providerMetadata)

      const finalItem = {
        type: 'complete' as const,
        object: finalResult
      }

      // Call progress callback for completion
      if (params.onProgress) {
        params.onProgress(finalResult, 'complete')
      }

      yield finalItem

    } catch (error: any) {
      // For streaming, we'll implement a simplified fallback that yields progress updates
      console.warn('Structured streaming failed, falling back to non-streaming with progress simulation:', error.message)
      
      try {
        // Use regular generateStructured as fallback, but simulate progress
        const result = await this.generateStructured({
          model: params.model,
          schema: params.schema,
          prompt: params.prompt,
          temperature: params.temperature,
          maxTokens: params.maxTokens
        })

        // Simulate progress by yielding a partial first, then complete
        yield {
          type: 'partial' as const,
          object: {} as Partial<T>
        }

        if (params.onProgress) {
          params.onProgress(result, 'complete')
        }

        yield {
          type: 'complete' as const,
          object: result
        }

      } catch (fallbackError) {
        throw error // Re-throw original streaming error
      }
    }
  }

  /**
   * Utility method to consume the entire stream and return the final object
   * Useful when you want streaming progress but need the final result
   */
  async generateStructuredWithProgress<T>(params: {
    model: string
    schema: z.ZodSchema<T>
    prompt: string
    temperature?: number
    maxTokens?: number
    onProgress?: (partialObject: Partial<T>, type: 'partial' | 'complete') => void
  }): Promise<T> {
    const stream = this.streamStructured(params)
    
    let finalResult: T | undefined
    
    for await (const item of stream) {
      if (item.type === 'complete') {
        finalResult = item.object as T
      }
    }

    if (!finalResult) {
      throw new Error('Stream completed without returning final object')
    }

    return finalResult
  }
}

export * from 'zod'
